C51 COMPILER V9.52.0.0   UART                                                              05/26/2021 20:02:34 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Output\uart.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\Source\uart.c LARGE BROWSE INCDIR(..\Source;..\User) DEBUG OBJECTEXTEND 
                    -PRINT(.\List\uart.lst) TABS(2) OBJECT(.\Output\uart.obj)

line level    source

   1          #include  "uart.h"
   2          #include  "oled.h"
   3          
   4          volatile uint8 Flag = FALSE;
   5          volatile uint8 xdata Rec_Buf4[Buf4_Max];     //接收串口4缓存数组
   6          volatile uint8 i = 0;                        //串口4接收数据个数变量 
   7          uint16 ctemp=100;
   8          
   9          /***************************************************************************
  10           * 描  述 : 串口1初始化函数
  11           * 入  参 : 无
  12           * 返回值 : 无
  13          备注：波特率9600bps   晶振11.0592MHz
  14           **************************************************************************/
  15          void Uart1_Init(void)
  16          { 
  17   1        PCON &= 0x3f;   //波特率不倍速，串行口工作方式由SM0、SM1决定
  18   1        SCON = 0x50;    //8位数据,可变波特率，启动串行接收器
  19   1        AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
  20   1        AUXR &= 0xfe;   //串口1选择定时器1为波特率发生器
  21   1        TMOD &= 0x0f;   //清除定时器1模式位
  22   1        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
  23   1        TL1 = 0xDC;     //设定定时初值
  24   1        TH1 = 0xDC;     //设定定时器重装值
  25   1        ET1 = 0;        //禁止定时器1中断
  26   1        TR1 = 1;        //启动定时器1
  27   1        ES = 1;         // 串口1中断打开
  28   1      }
  29          
  30          void Uart4_Init(void)
  31          {
  32   1        P_SW2 |= S4_S;     //选择P52、P53为串口4
  33   1      
  34   1        S4CON |= 0x10;    //启动串行接收器  
  35   1        S4CON &= 0x30;    //8位数据,可变波特率，串口4选择定时器2为波特率发生器
  36   1        AUXR |= 0x04;     //定时器2时钟为Fosc,即1T
  37   1        T2L = 0xE0;       //设定定时初值
  38   1        T2H = 0xFE;       //设定定时初值
  39   1        AUXR |= 0x10;     //启动定时器2
  40   1        IE2 |= 0x10;      //串口4中断打开
  41   1      }
  42          
  43          /***************************************************************************
  44           * 描  述 : 串口4发送数据函数
  45           * 入  参 : uint8 数据
  46           * 返回值 : 无
  47           **************************************************************************/
  48          void SendDataByUart4(uint8 dat)
  49          {
  50   1        S4BUF = dat;                 //写数据到UART数据寄存器
  51   1        while (!(S4CON & S4TI));        //在停止位没有发送时，S4TI为0即一直等待
  52   1        S4CON &= ~S4TI;                //清除S4CON寄存器对应S4TI位（该位必须软件清零）
  53   1      }
  54          
C51 COMPILER V9.52.0.0   UART                                                              05/26/2021 20:02:34 PAGE 2   

  55          /***************************************************************************
  56           * 描  述 : 串口1发送数据函数
  57           * 入  参 : uint8 数据
  58           * 返回值 : 无
  59           **************************************************************************/
  60          void SendDataByUart1(uint8 dat)
  61          {
  62   1          SBUF = dat;                 //写数据到UART数据寄存器
  63   1          while(TI == 0);             //在停止位没有发送时，TI为0即一直等待
  64   1          TI = 0;                     //清除TI位（该位必须软件清零）
  65   1      }
  66          
  67          /***************************************************************************
  68           * 描  述 : 串口4发送字符串函数
  69           * 入  参 : 字符串
  70           * 返回值 : 无
  71           **************************************************************************/
  72          void SendStringByUart4(char* s)
  73          {
  74   1        while (*s)                       //检测字符串结束标志
  75   1        {
  76   2          SendDataByUart4(*s++);         //发送当前字符
  77   2        }
  78   1      }
  79          
  80          /***************************************************************************
  81          功能描述：握手成功与否函数
  82          入口参数：unsigned char *a
  83          返回值：位
  84          ****************************************************************************/
  85          bit Hand(unsigned char* a)
  86          {
  87   1        if (strstr(Rec_Buf4, a) != NULL)       //判断字符串a是否是字符串Rec_Buf的子串
  88   1          return 1;                       //如果字符串a是字符串Rec_Buf的子串
  89   1        else
  90   1          return 0;
  91   1      }
  92          
  93          /***************************************************************************
  94           * 描  述 : 串口1发送字符串函数
  95           * 入  参 : uint8 *s 待发送字符串 
  96           * 返回值 : 无
  97           **************************************************************************/
  98          void SendStringByUart1(uint8 *s)
  99          {
 100   1        while(*s)
 101   1        {
 102   2          SendDataByUart1(*s++);       //将字符串中的字符一个一个发送
 103   2        }
 104   1      }
 105          
 106          /***************************************************************************
 107           * 描  述 : 重定向c库函数printf到USART1
 108           * 入  参 : char dat
 109           * 返回值 : char 
 110           **************************************************************************/
 111          char putchar(char dat)
 112          {
 113   1          SendDataByUart1(dat);           
 114   1          return dat;                    
 115   1      }
 116          
C51 COMPILER V9.52.0.0   UART                                                              05/26/2021 20:02:34 PAGE 3   

 117          /***************************************************************************
 118           * 描  述 : 串口1中断服务函数
 119           * 入  参 : 无
 120           * 返回值 : 无
 121           **************************************************************************/
 122          void Uart1() interrupt UART1_VECTOR using 1
 123          {
 124   1        ES = 0;                     // 串口1中断关闭
 125   1      
 126   1        if (RI)                     //串行接收到停止位的中间时刻时，该位置1
 127   1        {
 128   2            RI = 0;                 //清除RI位 （该位必须软件清零）
 129   2         }
 130   1         if (TI)                    //在停止位开始发送时，该位置1
 131   1         {
 132   2            TI = 0;                 //清除TI位（该位必须软件清零）
 133   2         }
 134   1         ES =  1;                   // 串口1中断打开
 135   1      }
 136          
 137          /**************************************************************************
 138          功能描述：清除串口4缓存内容函数
 139          入口参数：无
 140          返回值：无
 141          ***************************************************************************/
 142          void CLR_Buf4(void)
 143          {
 144   1        uint8 k;
 145   1        for (k = 0; k < Buf4_Max; k++)      //将串口4缓存数组的值都清为零
 146   1        {
 147   2          Rec_Buf4[k] = 0;
 148   2        }
 149   1        i = 0;                       //清零串口4接收数据个数变量             
 150   1      }
 151          
 152          /***************************************************************************
 153           * 描  述 : 串口4中断服务函数
 154           * 入  参 : 无
 155           * 返回值 : 无
 156           **************************************************************************/
 157          void Uart4() interrupt UART4_VECTOR using 1{
 158   1        IE2 &= 0xEF;                     //串口4中断关闭
 159   1        if (S4CON & S4RI)                //串行接收到停止位的中间时刻时，该位置1
 160   1        {
 161   2          S4CON &= ~S4RI;              //清除S4CON寄存器对应S4RI位（该位必须软件清零）
 162   2          Rec_Buf4[i] = S4BUF;         //把串口4缓存SBUF寄存器数据依次存放到数组Rec_Buf4中
 163   2          i++;
 164   2          if (i >= Buf4_Max)              //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 165   2          {
 166   3            i = 0;                   //清零串口4接收数据个数变量  
 167   3          }
 168   2        }
 169   1        if (S4CON & S4TI)                //在停止位开始发送时，该位置1
 170   1        {
 171   2          S4CON &= ~S4TI;              //清除S4CON寄存器对应S4TI位（该位必须软件清零）
 172   2        }
 173   1        IE2 |= 0x10;                     //串口4中断打开
 174   1      }
 175          
 176          int Read_DecNumber(const uint8* str, int n) {
 177   1        int value;
 178   1        int i;
C51 COMPILER V9.52.0.0   UART                                                              05/26/2021 20:02:34 PAGE 4   

 179   1      
 180   1        if (!str)
 181   1        {
 182   2          return 0;
 183   2        }
 184   1        value = 0;
 185   1      
 186   1        for (i = 0; i < n; i++) {
 187   2          if(*str==';')
 188   2            break;
 189   2          if ((*str >= '0') && (*str <= '9')) {
 190   3            value = value * 10 + (*str - '0');
 191   3          }
 192   2          str++;
 193   2        }
 194   1      
 195   1        return value;
 196   1      }
 197          
 198          /**************************************************************************************
 199           * 描  述 : HC08通信函数
 200           * 入  参 : 无
 201           * 返回值 : 无
 202           **************************************************************************************/
 203          void HC08_Tx_Puts(void) {
 204   1        if (Hand("STATEON"))                        //收到STATEON的指令
 205   1        {
 206   2          IE2 &= 0xEF;                           //串口4中断关闭
 207   2          state_all = 1;
 208   2        }
 209   1        else if (Hand("STATEOFF"))                   //收到STATEOFF的指令
 210   1        {
 211   2          IE2 &= 0xEF;                           //串口4中断关闭
 212   2          state_all = 0;
 213   2        }
 214   1        else if (Hand("SET"))                   //收到SET的指令
 215   1        {
 216   2          IE2 &= 0xEF;                           //串口4中断关闭
 217   2          ctemp = Read_DecNumber(Rec_Buf4, Buf4_Max);
 218   2        }
 219   1        CLR_Buf4();                            //清除串口4缓存           
 220   1        Uart4_Init();                          //串口4初始化，并打开串口4中断 
 221   1      }
 222          
 223          /*********************************END FILE********************************************/ 
 224          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    582    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =     24      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
