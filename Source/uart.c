#include	"uart.h"
#include	"oled.h"

volatile uint8 Flag = FALSE;
volatile uint8 xdata Rec_Buf4[Buf4_Max];     //接收串口4缓存数组
volatile uint8 i = 0;                        //串口4接收数据个数变量 
uint16 ctemp=100;

/***************************************************************************
 * 描  述 : 串口1初始化函数
 * 入  参 : 无
 * 返回值 : 无
备注：波特率9600bps   晶振11.0592MHz
 **************************************************************************/
void Uart1_Init(void)
{	
	PCON &= 0x3f;		//波特率不倍速，串行口工作方式由SM0、SM1决定
	SCON = 0x50;		//8位数据,可变波特率，启动串行接收器
	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
	AUXR &= 0xfe;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0f;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xDC;		  //设定定时初值
	TH1 = 0xDC;		  //设定定时器重装值
	ET1 = 0;		    //禁止定时器1中断
	TR1 = 1;		    //启动定时器1
	ES = 1;         // 串口1中断打开
}

void Uart4_Init(void)
{
	P_SW2 |= S4_S;     //选择P52、P53为串口4

	S4CON |= 0x10;		//启动串行接收器	
	S4CON &= 0x30;		//8位数据,可变波特率，串口4选择定时器2为波特率发生器
	AUXR |= 0x04;		  //定时器2时钟为Fosc,即1T
	T2L = 0xE0;		    //设定定时初值
	T2H = 0xFE;		    //设定定时初值
	AUXR |= 0x10;		  //启动定时器2
	IE2 |= 0x10;      //串口4中断打开
}

/***************************************************************************
 * 描  述 : 串口4发送数据函数
 * 入  参 : uint8 数据
 * 返回值 : 无
 **************************************************************************/
void SendDataByUart4(uint8 dat)
{
	S4BUF = dat;                 //写数据到UART数据寄存器
	while (!(S4CON & S4TI));        //在停止位没有发送时，S4TI为0即一直等待
	S4CON &= ~S4TI;                //清除S4CON寄存器对应S4TI位（该位必须软件清零）
}

/***************************************************************************
 * 描  述 : 串口1发送数据函数
 * 入  参 : uint8 数据
 * 返回值 : 无
 **************************************************************************/
void SendDataByUart1(uint8 dat)
{
    SBUF = dat;                 //写数据到UART数据寄存器
		while(TI == 0);             //在停止位没有发送时，TI为0即一直等待
		TI = 0;                     //清除TI位（该位必须软件清零）
}

/***************************************************************************
 * 描  述 : 串口4发送字符串函数
 * 入  参 : 字符串
 * 返回值 : 无
 **************************************************************************/
void SendStringByUart4(char* s)
{
	while (*s)                       //检测字符串结束标志
	{
		SendDataByUart4(*s++);         //发送当前字符
	}
}

/***************************************************************************
功能描述：握手成功与否函数
入口参数：unsigned char *a
返回值：位
****************************************************************************/
bit Hand(unsigned char* a)
{
	if (strstr(Rec_Buf4, a) != NULL)       //判断字符串a是否是字符串Rec_Buf的子串
		return 1;                       //如果字符串a是字符串Rec_Buf的子串
	else
		return 0;
}

/***************************************************************************
 * 描  述 : 串口1发送字符串函数
 * 入  参 : uint8 *s 待发送字符串 
 * 返回值 : 无
 **************************************************************************/
void SendStringByUart1(uint8 *s)
{
	while(*s)
	{
		SendDataByUart1(*s++);       //将字符串中的字符一个一个发送
	}
}

/***************************************************************************
 * 描  述 : 重定向c库函数printf到USART1
 * 入  参 : char dat
 * 返回值 : char 
 **************************************************************************/
char putchar(char dat)
{
		SendDataByUart1(dat);           
		return dat;                    
}

/***************************************************************************
 * 描  述 : 串口1中断服务函数
 * 入  参 : 无
 * 返回值 : 无
 **************************************************************************/
void Uart1() interrupt UART1_VECTOR using 1
{
	ES = 0;  	                  // 串口1中断关闭

	if (RI)                     //串行接收到停止位的中间时刻时，该位置1
  {
      RI = 0;                 //清除RI位 （该位必须软件清零）
   }
   if (TI)                    //在停止位开始发送时，该位置1
   {
      TI = 0;                 //清除TI位（该位必须软件清零）
   }
	 ES =  1;                   // 串口1中断打开
}

/**************************************************************************
功能描述：清除串口4缓存内容函数
入口参数：无
返回值：无
***************************************************************************/
void CLR_Buf4(void)
{
	uint8 k;
	for (k = 0; k < Buf4_Max; k++)      //将串口4缓存数组的值都清为零
	{
		Rec_Buf4[k] = 0;
	}
	i = 0;                       //清零串口4接收数据个数变量             
}

/***************************************************************************
 * 描  述 : 串口4中断服务函数
 * 入  参 : 无
 * 返回值 : 无
 **************************************************************************/
void Uart4() interrupt UART4_VECTOR using 1{
	IE2 &= 0xEF; 			               //串口4中断关闭
	if (S4CON & S4RI)                //串行接收到停止位的中间时刻时，该位置1
	{
		S4CON &= ~S4RI;              //清除S4CON寄存器对应S4RI位（该位必须软件清零）
		Rec_Buf4[i] = S4BUF;         //把串口4缓存SBUF寄存器数据依次存放到数组Rec_Buf4中
		i++;
		if (i >= Buf4_Max)              //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
		{
			i = 0;                   //清零串口4接收数据个数变量  
		}
	}
	if (S4CON & S4TI)                //在停止位开始发送时，该位置1
	{
		S4CON &= ~S4TI;   			     //清除S4CON寄存器对应S4TI位（该位必须软件清零）
	}
	IE2 |= 0x10;                     //串口4中断打开
}

int Read_DecNumber(const uint8* str, int n) {
	int value;
	int i;

	if (!str)
	{
		return 0;
	}
	value = 0;

	for (i = 0; i < n; i++) {
		if(*str==';')
			break;
		if ((*str >= '0') && (*str <= '9')) {
			value = value * 10 + (*str - '0');
		}
		str++;
	}

	return value;
}

/**************************************************************************************
 * 描  述 : HC08通信函数
 * 入  参 : 无
 * 返回值 : 无
 **************************************************************************************/
void HC08_Tx_Puts(void) {
	if (Hand("STATEON"))                        //收到STATEON的指令
	{
		IE2 &= 0xEF; 			                     //串口4中断关闭
		state_all = 1;
	}
	else if (Hand("STATEOFF"))                   //收到STATEOFF的指令
	{
		IE2 &= 0xEF; 			                     //串口4中断关闭
		state_all = 0;
	}
	else if (Hand("SET"))                   //收到SET的指令
	{
		IE2 &= 0xEF; 			                     //串口4中断关闭
		ctemp = Read_DecNumber(Rec_Buf4, Buf4_Max);
	}
	CLR_Buf4();		                         //清除串口4缓存				   
	Uart4_Init();                          //串口4初始化，并打开串口4中断	
}

/*********************************END FILE********************************************/	

